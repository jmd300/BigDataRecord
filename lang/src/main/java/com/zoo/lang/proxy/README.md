Java动态代理是一种在运行时生成代理类的技术，它可以在不修改原始类的情况下，为原始类提供额外的功能。
该技术基于Java反射机制实现，通过代理类与委托类之间的间接访问，可以使得代理类在不改变委托类结构的情况下，对目标方法进行增强或扩展。

Java动态代理主要有两种方式，分别是基于接口和基于类的动态代理。其中，基于接口的动态代理需要委托类实现一个接口，而基于类的动态代理则直接继承委托类。
无论是哪种方式，在动态代理生成代理类后，客户端都可以通过这个代理类来访问委托类，从而达到增强或扩展的目的。

Java动态代理的应用场景非常广泛，例如：
AOP（面向切面编程）：可以在不改变原有业务对象代码的情况下，通过对业务对象添加切面逻辑实现对业务对象的额外控制。
RPC（远程过程调用）：可以通过代理对象将本地业务对象的方法映射到远程服务端，并将远程服务端的调用结果返回给本地客户端。
防火墙、缓存、日志、事务等功能：通过代理对象增加额外的功能，比如在不修改原有业务代码的情况下，实现服务调用的安全控制、缓存数据、记录日志、实现事务等。
Java动态代理的优点在于可以在运行时动态生成代理类，无需预先编写代理类，从而使得代码更加灵活。同时，它还可以避免重复编写类似的代理代码，提高代码复用性和可维护性。


使用CGLIB代理相对于JDK动态代理的主要好处和区别如下：
无需实现接口：在使用JDK动态代理时，被代理的类必须要实现一个或多个接口；而在使用CGLIB动态代理时，则不需要被代理的类去实现任何接口。
更快的执行速度：由于CGLIB动态代理是基于字节码生成子类实现的，因此它比JDK动态代理更快。在调用目标方法时，JDK动态代理是通过反射的方式进行调用，而CGLIB动态代理则是通过直接调用子类中的方法来实现的。
支持对类的代理：JDK动态代理只能对实现了接口的类进行代理，而CGLIB动态代理可以对任意一个类进行代理。
可以自定义实现MethodInterceptor接口：CGLIB动态代理通过MethodInterceptor接口提供灵活的拦截器机制，可以自定义拦截器实现更为复杂的AOP操作。
限制较多：CGLIB动态代理对于final访问修饰符的方法无法代理；并且由于生成的代理对象是继承自原始对象，所以对于final类也无法进行代理。同时，JDK动态代理在某些情况下可能会出现不支持的异常。

综上所述，CGLIB代理相对于JDK代理来说在功能上更为强大、灵活并且性能更高，但也有一些限制，需要根据实际情况进行选择。如果被代理的对象没有实现接口或者需要进行复杂的AOP操作，建议使用CGLIB代理；
否则，可以优先考虑使用JDK动态代理。